當我們討論 0-1 背包問題時，通常會從一個基礎的 2 維動態規劃（DP）陣列開始，逐步優化到使用 1 維陣列來解決問題。以下我將一步步詳細解釋 0-1 背包問題如何從 2 維 DP 演變到 1 維 DP，並展示每次計算的變化過程。

---

### **0-1 背包問題的基礎介紹**

#### 問題描述：
給定一個容量為 `W` 的背包和 `n` 個物品，每個物品有：
- 重量 `w[i]`
- 價值 `v[i]`

目標是選擇物品放入背包，使得總重量不超過 `W`，且總價值最大。

#### 狀態定義：
- 設 `dp[i][j]` 表示「前 `i` 個物品中，當背包容量為 `j` 時的最大價值」。

#### 狀態轉移方程：
- 如果不選擇第 `i` 個物品：
  \[
  dp[i][j] = dp[i-1][j]
  \]
- 如果選擇第 `i` 個物品（且 `j \geq w[i]`）：
  \[
  dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])
  \]

---

### **從 2 維 DP 到 1 維 DP 的演變**

#### **2 維 DP 陣列的計算過程**
在 2 維 DP 中，`dp[i][j]` 依賴於上一層的值（即 `dp[i-1][j]` 和 `dp[i-1][j-w[i]]`）。以下是具體的計算過程：

##### 初始化：
- `dp[0][j] = 0`，因為沒有物品時，無論容量是多少，價值都為 0。

##### 遍歷物品和容量：
對於每個物品 `i` 和容量 `j`，我們根據是否選擇該物品來更新 `dp[i][j]`。

---

#### **優化到 1 維 DP 的核心思想**
1. **觀察依賴關係：**
   - 更新 `dp[i][j]` 時，只依賴於上一層的 `dp[i-1][j]` 和 `dp[i-1][j-w[i]]`。
   - 因此，我們不需要完整的 2 維陣列，只需要 1 維陣列來保存當前層的值。

2. **從後向前遍歷容量：**
   - 為了避免覆蓋掉上一層的值，我們必須從「後向前」遍歷容量 `j`，這樣在更新 `dp[j]` 時，`dp[j-w[i]]` 還是上一層的值。

---

### **1 維 DP 陣列的計算過程**

#### 狀態定義：
- 設 `dp[j]` 表示「當背包容量為 `j` 時的最大價值」。

#### 狀態轉移方程：
- 如果不選擇物品 `i`：
  \[
  dp[j] = dp[j]
  \]
- 如果選擇物品 `i`（且 `j \geq w[i]`）：
  \[
  dp[j] = \max(dp[j], dp[j-w[i]] + v[i])
  \]

#### **步驟詳細說明**

##### 初始化：
- `dp[j] = 0`，因為當沒有物品時，無論容量是多少，價值都為 0。

##### 遍歷物品和容量：
對於每個物品 `i` 和容量 `j`，從後向前遍歷 `j`，更新 `dp[j]`。

---

### **具體例子：**

#### **問題設定**
假設有以下物品和背包容量：
- 物品數據：`w = [2, 3, 4]`，`v = [3, 4, 5]`
- 背包容量：`W = 5`

我們目標是計算最大價值。

---

#### **1. 初始化**
- 初始的 `dp` 陣列為：
  ```
  dp = [0, 0, 0, 0, 0, 0]  # 容量從 0 到 5
  ```

---

#### **2. 處理第 1 個物品（重量 = 2，價值 = 3）**
- 從容量 `j = 5` 到 `j = 2` 更新：
  - 當 `j = 5`：
    \[
    dp[5] = \max(dp[5], dp[5-2] + 3) = \max(0, 0 + 3) = 3
    \]
  - 當 `j = 4`：
    \[
    dp[4] = \max(dp[4], dp[4-2] + 3) = \max(0, 0 + 3) = 3
    \]
  - 當 `j = 3`：
    \[
    dp[3] = \max(dp[3], dp[3-2] + 3) = \max(0, 0 + 3) = 3
    \]
  - 當 `j = 2`：
    \[
    dp[2] = \max(dp[2], dp[2-2] + 3) = \max(0, 0 + 3) = 3
    \]

- 更新後的 `dp`：
  ```
  dp = [0, 0, 3, 3, 3, 3]
  ```

---

#### **3. 處理第 2 個物品（重量 = 3，價值 = 4）**
- 從容量 `j = 5` 到 `j = 3` 更新：
  - 當 `j = 5`：
    \[
    dp[5] = \max(dp[5], dp[5-3] + 4) = \max(3, 3 + 4) = 7
    \]
  - 當 `j = 4`：
    \[
    dp[4] = \max(dp[4], dp[4-3] + 4) = \max(3, 0 + 4) = 4
    \]
  - 當 `j = 3`：
    \[
    dp[3] = \max(dp[3], dp[3-3] + 4) = \max(3, 0 + 4) = 4
    \]

- 更新後的 `dp`：
  ```
  dp = [0, 0, 3, 4, 4, 7]
  ```

---

#### **4. 處理第 3 個物品（重量 = 4，價值 = 5）**
- 從容量 `j = 5` 到 `j = 4` 更新：
  - 當 `j = 5`：
    \[
    dp[5] = \max(dp[5], dp[5-4] + 5) = \max(7, 0 + 5) = 7
    \]
  - 當 `j = 4`：
    \[
    dp[4] = \max(dp[4], dp[4-4] + 5) = \max(4, 0 + 5) = 5
    \]

- 更新後的 `dp`：
  ```
  dp = [0, 0, 3, 4, 5, 7]
  ```

---

### **最終結果**
- 背包容量為 5 時的最大價值為 `dp[5] = 7`。

---

### **總結**

1. **關鍵點：**
   - 從後向前遍歷容量，確保當前層的值不會覆蓋上一層的值。
   - 每次更新 `dp[j]` 時，考慮是否選擇當前物品。

2. **優化效果：**
   - 從 2 維 DP 優化到 1 維 DP，將空間複雜度從 \( O(n \times W) \) 降低到 \( O(W) \)。

3. **適用場景：**
   - 1 維 DP 適用於標準的 0-1 背包問題，能有效節省空間並保持正確性。